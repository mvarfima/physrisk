from collections import defaultdict
from typing import Iterable, List, Tuple, Union, cast

import numpy as np
from scipy.stats import multivariate_normal, norm

from physrisk.api.v1.common import VulnerabilityCurve, VulnerabilityCurves
from physrisk.kernel.assets import Asset, ThermalPowerGeneratingAsset, TurbineKind
from physrisk.kernel.impact_distrib import ImpactDistrib, ImpactType
from physrisk.kernel.vulnerability_model import DeterministicVulnerabilityModel, VulnerabilityModelBase

from ..kernel.curve import ExceedanceCurve
from ..kernel.hazard_event_distrib import HazardEventDistrib
from ..kernel.hazard_model import (
    HazardDataRequest,
    HazardDataResponse,
    HazardEventDataResponse,
    HazardParameterDataResponse,
)
from ..kernel.hazards import (
    CoastalInundation,
    RiverineInundation,
    ChronicWind,
    Fire,
    WaterStress,
    Landslide,
    Subsidence,
)
from ..kernel.vulnerability_distrib import VulnerabilityDistrib
from ..kernel.vulnerability_model import applies_to_assets, applies_to_events, get_vulnerability_curves_from_resource


class ThermalPowerGenerationInundationModel(DeterministicVulnerabilityModel):
    # Number of disrupted days per year
    _default_resource = "WRI thermal power plant physical climate vulnerability factors"

    # delimitation of the area for the hazard data expressed in metres (within [0,1000]).
    _default_buffer = None

    def __init__(
        self, *, hazard_type: type, indicator_id: str, resource: str = _default_resource, buffer: int = _default_buffer
    ):
        """
        Inundation vulnerability model for thermal power generation.
        Applies to both riverine and coastal inundation.

        Args:
                hazard_type (type): _description_
                indicator_id (str): ID of the hazard indicator to which this applies.
                resource (str): embedded resource identifier used to infer vulnerability table.
                buffer (int): delimitation of the area for the hazard data expressed in metres (within [0,1000]).
        """

        curve_set: VulnerabilityCurves = get_vulnerability_curves_from_resource(resource)

        # for this model, key for looking up curves is asset_type, e.g. 'Steam/Recirculating'
        self.vulnerability_curves = dict(
            (c.asset_type, c) for c in curve_set.items if c.event_type == hazard_type.__base__.__name__  # type:ignore
        )
        self.vuln_curves_by_type = defaultdict(list)
        for key in self.vulnerability_curves:
            self.vuln_curves_by_type[TurbineKind[key.split("/")[0]]].append(self.vulnerability_curves[key])

        impact_type = (
            ImpactType.disruption
            if len(self.vulnerability_curves) == 0
            else [ImpactType[self.vulnerability_curves[key].impact_type.lower()] for key in self.vulnerability_curves][
                0
            ]
        )

        # global circulation parameter 'model' is a hint; can be overriden by hazard model
        super().__init__(
            indicator_id=indicator_id,
            hazard_type=hazard_type,
            impact_type=impact_type,
            damage_curve_intensities=[],
            damage_curve_impacts=[],
            buffer=buffer,
        )

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        """Provide the list of hazard event data requests required in order to calculate
        the VulnerabilityDistrib and HazardEventDistrib for the asset."""
        request_scenario = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
            buffer=self.buffer,
        )
        request_baseline = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario='historical',
            year=1971,
            indicator_id=self.indicator_id,
            buffer=self.buffer,
        )
        return request_scenario, request_baseline

    def get_distributions(
        self, asset: Asset, event_data_responses: Iterable[HazardDataResponse]
    ) -> Tuple[VulnerabilityDistrib, HazardEventDistrib]:
        assert isinstance(asset, ThermalPowerGeneratingAsset)

        (response_scenario, response_baseline) = event_data_responses
        assert isinstance(response_scenario, HazardEventDataResponse)
        assert isinstance(response_baseline, HazardEventDataResponse)

        baseline_curve = ExceedanceCurve(1.0 / response_baseline.return_periods, response_baseline.intensities)
        protection_depth = (
            0.0
            if len(response_baseline.intensities) == 0
            else baseline_curve.get_value(1.0 / asset.get_inundation_protection_return_period())
        )

        intensity_curve = ExceedanceCurve(1.0 / response_scenario.return_periods, response_scenario.intensities)
        if 0 < len(intensity_curve.values):
            if intensity_curve.values[0] < protection_depth:
                if protection_depth < intensity_curve.values[-1]:
                    intensity_curve = intensity_curve.add_value_point(protection_depth)

        intensities, probs = intensity_curve.get_probability_bins()
        if 0 < len(intensity_curve.values):
            probs = np.insert(probs, 0, intensity_curve.probs[0])

        curves: List[VulnerabilityCurve] = []
        if asset.turbine is None:
            curves = [self.vulnerability_curves[key] for key in self.vulnerability_curves]
        elif asset.cooling is not None:
            key = "/".join([asset.turbine.name, asset.cooling.name])
            if key in self.vulnerability_curves:
                curves = [self.vulnerability_curves[key]]
        elif asset.turbine in self.vuln_curves_by_type:
            curves = self.vuln_curves_by_type[asset.turbine]

        if 0 < len(curves):
            impacts = [
                (
                    np.max([np.interp(intensity, curve.intensity, curve.impact_mean) for curve in curves]) / 365.0
                    if protection_depth < intensity
                    else 0.0
                )
                for intensity in intensities
            ]
        else:
            impacts = [0.0 for _ in intensities]

        vul = VulnerabilityDistrib(self.hazard_type, intensities, impacts, np.eye(len(probs), len(probs)))
        event = HazardEventDistrib(self.hazard_type, intensities, probs)
        return vul, event


@applies_to_events([CoastalInundation])
@applies_to_assets([ThermalPowerGeneratingAsset])
class ThermalPowerGenerationCoastalInundationModel(ThermalPowerGenerationInundationModel):
    def __init__(
        self,
        *,
        indicator_id: str = "flood_depth",
        resource: str = ThermalPowerGenerationInundationModel._default_resource
    ):
        # by default include subsidence and 95% sea-level rise
        super().__init__(hazard_type=CoastalInundation, indicator_id=indicator_id, resource=resource)


@applies_to_events([RiverineInundation])
@applies_to_assets([ThermalPowerGeneratingAsset])
class ThermalPowerGenerationRiverineInundationModel(ThermalPowerGenerationInundationModel):
    def __init__(
        self,
        *,
        indicator_id: str = "flood_depth",
        resource: str = ThermalPowerGenerationInundationModel._default_resource
    ):
        # by default request HazardModel to use "MIROC-ESM-CHEM" GCM
        super().__init__(hazard_type=RiverineInundation, indicator_id=indicator_id, resource=resource)


class SevereConvectiveWindstormModel(VulnerabilityModelBase):

    def __init__(self):
        """
        """
        self.indicator_id = "wind25"
        self.hazard_type = ChronicWind

    def get_data_requests(self, asset: Asset, *, scenario: str, year: int):
        return HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )

    def get_impact(self, asset: Asset, data_responses: List[HazardDataResponse]) -> ImpactDistrib:
        (data,) = data_responses
        assert isinstance(data, HazardParameterDataResponse)
        return ImpactDistrib(ChronicWind, [data.parameter, data.parameter], [1])
    

class HighFireModel(VulnerabilityModelBase):

    def __init__(self):
        """
        """
        self.indicator_id = "fwi20"
        self.hazard_type = Fire

    def get_data_requests(self, asset: Asset, *, scenario: str, year: int):
        return HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )

    def get_impact(self, asset: Asset, data_responses: List[HazardDataResponse]) -> ImpactDistrib:
        (data,) = data_responses
        assert isinstance(data, HazardParameterDataResponse)
        return ImpactDistrib(Fire, [data.parameter, data.parameter], [1])


class WaterstressModel(VulnerabilityModelBase):

    def __init__(self):
        """
        """
        self.indicator_id = "water_stress"
        self.hazard_type = WaterStress

    def get_data_requests(self, asset: Asset, *, scenario: str, year: int):
        return HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )

    def get_impact(self, asset: Asset, data_responses: List[HazardDataResponse]) -> ImpactDistrib:
        (data,) = data_responses
        assert isinstance(data, HazardParameterDataResponse)
        return ImpactDistrib(WaterStress, [data.parameter, data.parameter], [1])
    

class LandslideModel(VulnerabilityModelBase):

    def __init__(self):
        """
        """
        self.indicator_id = "susceptability"
        self.hazard_type = Landslide

    def get_data_requests(self, asset: Asset, *, scenario: str, year: int):
        return HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )

    def get_impact(self, asset: Asset, data_responses: List[HazardDataResponse]) -> ImpactDistrib:
        (data,) = data_responses
        assert isinstance(data, HazardParameterDataResponse)
        return ImpactDistrib(Landslide, [data.parameter, data.parameter], [1])
    

class SubsidenceModel(VulnerabilityModelBase):

    def __init__(self):
        """
        """
        self.indicator_id = "susceptability"
        self.hazard_type = Subsidence

    def get_data_requests(self, asset: Asset, *, scenario: str, year: int):
        return HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )

    def get_impact(self, asset: Asset, data_responses: List[HazardDataResponse]) -> ImpactDistrib:
        (data,) = data_responses
        assert isinstance(data, HazardParameterDataResponse)
        return ImpactDistrib(Subsidence, [data.parameter, data.parameter], [1])