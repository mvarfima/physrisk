from typing import Iterable, Union

import numpy as np

from ..kernel.assets import Asset, PowerGeneratingAsset
from ..kernel.curve import ExceedanceCurve
from ..kernel.hazard_event_distrib import HazardEventDistrib
from ..kernel.hazard_model import HazardDataRequest, HazardDataResponse, HazardEventDataResponse
from ..kernel.hazards import Drought, RiverineInundation, CoastalInundation, Wind, Fire, WaterStress
from ..kernel.impact_distrib import ImpactType
from ..kernel.vulnerability_distrib import VulnerabilityDistrib
from ..kernel.vulnerability_model import DeterministicVulnerabilityModel, VulnerabilityModelAcuteBase, applies_to_assets, VulnerabilityModelBase


from collections import defaultdict
from typing import Dict, List, Tuple

import numpy as np

from physrisk.api.v1.common import VulnerabilityCurve, VulnerabilityCurves
from physrisk.kernel.assets import Asset, RealEstateAsset
from physrisk.kernel.hazard_model import HazardDataRequest, HazardDataResponse, HazardParameterDataResponse
from physrisk.kernel.impact_distrib import ImpactDistrib, ImpactType
from physrisk.kernel.vulnerability_matrix_provider import VulnMatrixProvider
from physrisk.kernel.vulnerability_model import VulnerabilityModel

from ..kernel.hazards import ChronicHeat, CoastalInundation, RiverineInundation, Wind
from ..kernel.vulnerability_model import (
    DeterministicVulnerabilityModel,
    VulnerabilityModelBase,
    applies_to_events,
    checked_beta_distrib,
    get_vulnerability_curves_from_resource,
)


@applies_to_assets([PowerGeneratingAsset])
class RiverInundationModel(VulnerabilityModelAcuteBase):
    def __init__(self, indicator_id="flood_depth"):
        # default impact curve
        self.__curve_depth = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 1])
        self.__curve_impact = np.array([0, 1, 2, 7, 14, 30, 60, 180, 365])
        self.__indicator_id = indicator_id
        super().__init__(indicator_id=indicator_id, hazard_type=RiverineInundation, impact_type=ImpactType.disruption)
        pass

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        """Provide the list of hazard event data requests required in order to calculate
        the VulnerabilityDistrib and HazardEventDistrib for the asset."""

        histo = HazardDataRequest(
            RiverineInundation,
            asset.longitude,
            asset.latitude,
            scenario="historical",
            year=1971,
            indicator_id="flood_depth",
        )

        future = HazardDataRequest(
            RiverineInundation,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.__indicator_id,
        )

        return histo, future

    def get_distributions(self, asset: Asset, event_data_responses: Iterable[HazardDataResponse]):
        """Return distributions for asset, based on hazard event date:
        VulnerabilityDistrib and HazardEventDistrib."""

        histo, future = event_data_responses
        assert isinstance(histo, HazardEventDataResponse)
        assert isinstance(future, HazardEventDataResponse)

        protection_return_period = 250.0
        curve_histo = ExceedanceCurve(1.0 / histo.return_periods, histo.intensities)
        # the protection depth is the 250-year-return-period inundation depth at the asset location
        protection_depth = curve_histo.get_value(1.0 / protection_return_period)

        curve_future = ExceedanceCurve(1.0 / future.return_periods, future.intensities)
        curve_future = curve_future.add_value_point(protection_depth)

        depth_bins, probs = curve_future.get_probability_bins()

        impact_bins = np.interp(depth_bins, self.__curve_depth, self.__curve_impact) / 365.0

        # keep all bins, but make use of vulnerability matrix to apply protection level
        # for improved performance we could truncate (and treat identify matrix as a special case)
        # but this general version allows model uncertainties to be added
        probs_protected = np.where(depth_bins[1:] <= protection_depth, 0.0, 1.0)

        vul = VulnerabilityDistrib(RiverineInundation, depth_bins, impact_bins, np.diag(probs_protected))
        event = HazardEventDistrib(RiverineInundation, depth_bins, probs)

        return vul, event


@applies_to_assets([PowerGeneratingAsset])
class CoastalInundationModel(VulnerabilityModelAcuteBase):
    def __init__(self, indicator_id="flood_depth"):
        # default impact curve
        self.__curve_depth = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 1])
        self.__curve_impact = np.array([0, 1, 2, 7, 14, 30, 60, 180, 365])
        self.__indicator_id = indicator_id
        super().__init__(indicator_id=indicator_id, hazard_type=CoastalInundation, impact_type=ImpactType.disruption)
        pass

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        """Provide the list of hazard event data requests required in order to calculate
        the VulnerabilityDistrib and HazardEventDistrib for the asset."""

        histo = HazardDataRequest(
            CoastalInundation,
            asset.longitude,
            asset.latitude,
            scenario="historical",
            year=1971,
            indicator_id="flood_depth",
        )

        future = HazardDataRequest(
            CoastalInundation,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.__indicator_id,
        )

        return histo, future

    def get_distributions(self, asset: Asset, event_data_responses: Iterable[HazardDataResponse]):
        """Return distributions for asset, based on hazard event date:
        VulnerabilityDistrib and HazardEventDistrib."""

        histo, future = event_data_responses
        assert isinstance(histo, HazardEventDataResponse)
        assert isinstance(future, HazardEventDataResponse)

        protection_return_period = 250.0
        curve_histo = ExceedanceCurve(1.0 / histo.return_periods, histo.intensities)
        # the protection depth is the 250-year-return-period inundation depth at the asset location
        protection_depth = curve_histo.get_value(1.0 / protection_return_period)

        curve_future = ExceedanceCurve(1.0 / future.return_periods, future.intensities)
        curve_future = curve_future.add_value_point(protection_depth)

        depth_bins, probs = curve_future.get_probability_bins()

        impact_bins = np.interp(depth_bins, self.__curve_depth, self.__curve_impact) / 365.0

        # keep all bins, but make use of vulnerability matrix to apply protection level
        # for improved performance we could truncate (and treat identify matrix as a special case)
        # but this general version allows model uncertainties to be added
        probs_protected = np.where(depth_bins[1:] <= protection_depth, 0.0, 1.0)

        vul = VulnerabilityDistrib(CoastalInundation, depth_bins, impact_bins, np.diag(probs_protected))
        event = HazardEventDistrib(CoastalInundation, depth_bins, probs)

        return vul, event


@applies_to_assets([PowerGeneratingAsset])
class WindVulModel(VulnerabilityModelAcuteBase):
    def __init__(self, indicator_id="gust_speed_level"):
        # default impact curve
        self.__curve_depth = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 1])*70
        self.__curve_impact = np.array([0, 1, 2, 7, 14, 30, 60, 180, 365])
        self.__indicator_id = indicator_id
        super().__init__(indicator_id=indicator_id, hazard_type=Wind, impact_type=ImpactType.disruption)
        pass

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        """Provide the list of hazard event data requests required in order to calculate
        the VulnerabilityDistrib and HazardEventDistrib for the asset."""

        histo = HazardDataRequest(
            Wind,
            asset.longitude,
            asset.latitude,
            scenario="historical",
            year=1980,
            indicator_id="gust_speed_level",
        )

        future = HazardDataRequest(
            Wind,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.__indicator_id,
        )

        return histo, future

    def get_distributions(self, asset: Asset, event_data_responses: Iterable[HazardDataResponse]):
        """Return distributions for asset, based on hazard event date:
        VulnerabilityDistrib and HazardEventDistrib."""

        histo, future = event_data_responses
        assert isinstance(histo, HazardEventDataResponse)
        assert isinstance(future, HazardEventDataResponse)

        protection_return_period = 250.0
        curve_histo = ExceedanceCurve(1.0 / histo.return_periods, histo.intensities)
        # the protection depth is the 250-year-return-period inundation depth at the asset location
        protection_depth = curve_histo.get_value(1.0 / protection_return_period)

        curve_future = ExceedanceCurve(1.0 / future.return_periods, future.intensities)
        curve_future = curve_future.add_value_point(protection_depth)

        depth_bins, probs = curve_future.get_probability_bins()

        impact_bins = np.interp(depth_bins, self.__curve_depth, self.__curve_impact) / 365.0

        # keep all bins, but make use of vulnerability matrix to apply protection level
        # for improved performance we could truncate (and treat identify matrix as a special case)
        # but this general version allows model uncertainties to be added
        probs_protected = np.where(depth_bins[1:] <= protection_depth, 0.0, 1.0)

        vul = VulnerabilityDistrib(RiverineInundation, depth_bins, impact_bins, np.diag(probs_protected))
        event = HazardEventDistrib(RiverineInundation, depth_bins, probs)

        return vul, event
    
@applies_to_assets([PowerGeneratingAsset])
class WildFireVulModel(VulnerabilityModelBase):
    def __init__(self, indicator_id="fwi20"):
        # default impact curve
        self.__curve_depth = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 1])*100
        self.__curve_impact = np.array([0, 1, 2, 7, 14, 30, 60, 180, 365])
        self.__indicator_id = indicator_id
        super().__init__(indicator_id=indicator_id, hazard_type=Fire, impact_type=ImpactType.disruption)
        pass

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        """Provide the list of hazard event data requests required in order to calculate
        the VulnerabilityDistrib and HazardEventDistrib for the asset."""

        histo = HazardDataRequest(
            Fire,
            asset.longitude,
            asset.latitude,
            scenario="historical",
            year=1971,
            indicator_id="fwi20",
        )

        future = HazardDataRequest(
            Fire,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.__indicator_id,
        )

        return histo, future

    def get_impact(self, asset: Asset, data_responses: List[HazardDataResponse]) -> ImpactDistrib:
        histo, future = data_responses
        values = [histo.intensities[0], future.intensities[0]]
        values.sort()
        return ImpactDistrib(Fire, values, [1])


@applies_to_assets([PowerGeneratingAsset])
class WaterStressVulModel(VulnerabilityModelBase):
    def __init__(self, indicator_id="water_stress"):
        # default impact curve
        self.__curve_depth = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 1])*100
        self.__curve_impact = np.array([0, 1, 2, 7, 14, 30, 60, 180, 365])
        self.__indicator_id = indicator_id
        super().__init__(indicator_id=indicator_id, hazard_type=WaterStress, impact_type=ImpactType.disruption)
        pass

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        """Provide the list of hazard event data requests required in order to calculate
        the VulnerabilityDistrib and HazardEventDistrib for the asset."""

        histo = HazardDataRequest(
            WaterStress,
            asset.longitude,
            asset.latitude,
            scenario="rcp26",
            year=2020,
            indicator_id="water_stress",
        )

        future = HazardDataRequest(
            WaterStress,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.__indicator_id,
        )

        return histo, future

    def get_impact(self, asset: Asset, data_responses: List[HazardDataResponse]) -> ImpactDistrib:
        histo, future = data_responses
        values = [histo.intensities[0], future.intensities[0]]
        values.sort()
        return ImpactDistrib(WaterStress, values, [1])


class TemperatureModel(DeterministicVulnerabilityModel):
    def __init__(self):
        # does nothing
        pass


class SimpleDroughtModel(DeterministicVulnerabilityModel):
    def __init__(self):
        """This is a simple pre-cursor model to a model based on:
        Luo T, Zhou L, Falzon J, Cheng Y, Christianson G, Wu Y, Habchi A. Assessing Physical Climate Risks for the
        European Bank for Reconstruction and Development's Power Generation Project Investment Portfolio.
        This simple model uses only a single indicator providing number of months per year where 3-month
        SPEI is less than -2 as opposed to information related to SPEI -1.5, -2, -2.5 etc.
        """
        intensities = np.array([0, 2, 4, 6, 8, 10, 12])
        impacts = intensities * 0.1 / 12
        super().__init__(
            hazard_type=Drought,
            damage_curve_intensities=intensities,
            damage_curve_impacts=impacts,
            indicator_id="months/spei3m/below/-2",
        )
